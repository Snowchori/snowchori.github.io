---
layout: post
title:  "Tree"
date:   2021-11-28 15:00:00 +0900
category: DataStructure
---

# Tree

## Tree의 개념

- 트리는 노드로 이루어진 자료 구조
- 트리는 하나의 루트 노드를 갖는다
- 루트 노드는 0개 이상의 자식 노드를 갖고있다
- 그 자식 노드 또한 0개 이상의 자식 노드를 갖고있고 이는 반복적으로 정의된다
- 노드들과 노드들을 연결하는 간선들로 구성되어 있다
  * 트리에는 사이클이 존재할 수 없다
  * 노드들은 특정 순서로 나열될 수도 있고 그럴 수 없을 수도 있다
  * 각 노드는 부모 노드로의 연결이 있을 수도 있고 없을 수도 있다
  * 각 노드는 어떤 자료형으로도 표현 가능하다
- 비선형 자료구조로 계층적 관계를 표현한다

## Tree와 관련된 용어

- 루트 노드 : 부모가 없는 노드, 트리는 하나의 루트 노드만을 가진다
- 단말 노드 : 자식이 없는 노드, 말단 노드 또는 잎 노드라고도 부른다
- 내부 노드 : 단말 노드가 아닌 노드
- 간선 : 노드를 연결하는 선
- 형제 : 같은 부모를 가지는 노드
- 노드의 크기 : 자신을 포함한 모든 자손 노드의 개수
- 노드의 깊이 : 루트에서 어떤 노드에 도달하기 위해 거쳐야 하는 간선의 수
- 노드의 레벨 : 트리의 특정 깊이를 가지는 노드의 집합
- 노드의 차수 : 하위 트리 개수 / 간선 수 = 각 노드가 지닌 가지의 수
- 트리의 차수 : 트리의 최대 차수
- 트리의 높이 : 루트 노드에서 가장 깊숙히 있는 노드의 깊이

## Tree의 특징

- 그래프의 한 종류이다 최소 연결 트리라고도 불린다
- 트리는 계층 모델이다
- 트리는 DAG(Directed Acyclic Graphs, 방향성이 있는 비순환 그래프)의 한 종류이다
  * loop나 circuit이 없다
  * 사이클이 없다
- 노드가 N개인 트리는 항상 N-1개의 간선을 가진다
  * 간선은 항상 (정점의 개수-1) 만큼을 가진다
- 루트에서 어떤 노드로 가는 경로는 유일하다
  * 임이의 두 노드 간의 경로도 유일하다 즉, 두 개의 정점 사이에 반드시 1개의 경로만을 가진다
- 한 개의 루트 노드만이 존재하며 모든 자식 노드는 한 개의 부모 노드만을 가진다
  * 부모-자식 관계이므로 흐름은 top-bottom 아니면 bottom-top으로 이루어진다
- 순회는 Pre-order, In-order, Post-order로 이루어진다

## 이진 트리

### 이진 트리란?

- 이진 트리는 모든 노드가 2개의 서브 트리를 가지고 있는 트리
- 트리 중에서 가장 많이 쓰인다
- 서브 트리 또한 모두 이진 트리여야 하기 때문에 순환적으로 정의되고 있다
- 이진 트리의 서브트리는 공집합일 수 있다
- 이진 트리에는 서브 트리간의 순서가 존재해 왼쪽 서브 트리와 오른쪽 서브 트리는 구별된다

### 이진 트리와 일반 트리의 차이점

<img src="http://snowchori.github.io/assets/img/binary_tree.png">

### 이진 트리 성질

- n개의 노드를 가진 이진 트리는 n-1개의 간선을 가진다
- 높이가 h인 이진 트리의 경우 최소 h개의 노드를 가지며 최대 2^h-1개의 노드를 가진다
- n개의 노드를 가지는 이진 트리의 높이는 최대 n이거나 최소 ┌log₂(n+1)┐이 된다

### 이진 트리 분류

<img src="http://snowchori.github.io/assets/img/complete_binary_tree.png">

- 완전 이진 트리
  * 트리의 모든 높이에서 노드가 꽉 차있는 이진 트리
  * 마지막 레벨을 제외하고 모든 레벨이 완전히 채워져 있다
  * 마지막 레벨은 꽉 차 있지 않아도 되지만 노드가 왼쪽에서 오른쪽으로 채워져야 한다
  * 마지막 레벨 h에서 (1 ~ 2h-1)개의 노드를 가질 수 있다
  * 또 다른 정의는 가장 오른쪽의 잎 노드가 제거된 포화 이진 트리
  * 완전 이진 트리는 배열을 사용해 효율적으로 표현 가능하다

<img src="http://snowchori.github.io/assets/img/full_binary_tree.png">

- 전 이진 트리
  * 모든 노드가 0개 또는 2개의 자식 노드를 갖는 트리

<img src="http://snowchori.github.io/assets/img/perfect_binary_tree.png">

- 포화 이진 트리
  * 전 이진 트리이면서 완전 이진 트리인 경우
  * 모든 말단 노드는 같은 높이에 있어야 하며 마지막 단계에서 노드의 개수가 최대가 되어야 한다
  * 모든 내부 노드가 두 개의 자식 노드를 가진다
  * 모든 말단 노드가 동일한 깊이 또는 레벨을 갖는다
  * 노드의 개수가 정확히 2^(k-1)개여야 한다 (k: 트리의 높이)
    
## 이진 힙

### 최소 힙

- 트리의 마지막 단계에서 오른쪽 부분을 뺀 나머지 부분이 가득 채워져있는 완전 이진 트리이며
  각 노드의 원소가 자식들의 원소보다 작다
- key(부모 노드) >= key(자식 노드)인 완전 이진 트리
- 가장 큰 값은 루트 노드이다
- N개가 힙에 들어가 있으면 높이는 log(N)이다

### 최대 힙

- 원소가 내림차순으로 정렬되어 있다는 점에서만 최소힙과 다르다
- 각 노드의 원소가 자식들의 원소보다 크다

## 이진 탐색 트리

- 이진 탐색 트리란 정렬된 이진트리로써 다음과 같은 속성을 가지고 있다
  * 노드의 왼쪽 하위 트리에는 노드의 키보다 작은 키가있는 노드만 포함된다
  * 노드의 오른쪽 하위 트리에는 노드의 키보다 큰 키가있는 노드만 포함된다
  * 왼쪽 및 오른쪽 하위 트리도 각각 이진 검색 트리여야한다
  * 중복된 키를 허용하지 않는다

<img src="http://snowchori.github.io/assets/img/binary_search_tree.png">

## 이진 탐색 트리 특징

- BST의 Inorder Traversal을 수행하여 모든 키를 정렬된 순서로 가져올 수 있다
- BST의 검색에 대한 시간복잡도는 균형 상태이면 O(logN)의 시간이 걸리고
  불균형 상태라면 최대 O(N) 시간이 걸린다

## 이진 트리의 연산

### 검색

- 이진 탐색 트리에서 특정 요소의 위치를 찾는다

1. 루트에서 시작
2. 검색 값을 루트와 비교 루트보다 작으면 왼쪽으로 재귀하고 크다면 오른쪽으로 재귀
3. 일치하는 값을 찾을 때까지 절차를 반복
4. 검색 값이 없으면 null 반환

### 삽입

- 이진 검색트리에 데이터를 삽입하는 작업
- 새 키는 항상 리프 노드에 삽입

1. 루트에서 시작
2. 검색 값을 루트와 비교 루트보다 작으면 왼쪽으로 재귀하고 크다면 오른쪽으로 재귀
3. 리프 노드에 도달한 후 노드보다 크다면 오른쪽에 작다면 왼쪽에 삽입

### 삭제

- 이진 검색 트리에서 특정 노드를 삭제
- 삭제할 노드가 리프노드인 경우
  * 노드를 삭제하기만 하면 된다
- 삭제할 노드에 자식이 하나만 있는 경우
  * 노드를 삭제하고 자식 노드를 삭제된 부모에 직접 연결
- 삭제할 노드에 자식이 둘 있는 경우
  * 자식이 둘 있는 경우 successor 노드를 찾는 과정이 추가
- surrcessor 노드란
  * right subtree에 최소값
  * inorder 순회에서 다음 노드

1. 삭제할 노드를 찾는다
2. 삭제할 노드의 successor 노드를 찾는다
3. 삭제할 노드와 successor 노드의 값을 바꾼다
4. successor 노드를 삭제

### [참고]
<https://gmlwjd9405.github.io/2018/08/12/data-structure-tree.html> <br>
<https://medium.com/quantum-ant/%ED%8A%B8%EB%A6%AC-tree-cec69cfddb14> <br>
<https://yoongrammer.tistory.com/71>